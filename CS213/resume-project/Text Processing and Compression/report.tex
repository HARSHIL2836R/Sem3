\documentclass[10pt,a4paper]{report}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,
    urlcolor=cyan,
}

% Define code styling
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{lightgray},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green},
    showspaces=false,
    showstringspaces=false,
}

\title{\texttt{Project Report:}\\ Deflate Compression, LZ77, and Context-aware Autocomplete using Tries and KMP Algorithm}
\author{Harshil Solanki\\
        Data Structures and Algorithms}
\date{September 2024}

\begin{document}

\maketitle

\tableofcontents

\chapter{Introduction}
Data compression and efficient text handling are crucial areas in computer science. This project focuses on three major algorithms and data structures under the domain of data structures and algorithms:
\begin{enumerate}
    \item Context-aware Autocomplete using Tries and KMP Algorithm.
    \item Lempel-Ziv'77 (LZ77) Compression and Decompression.
    \item Deflate Compression Algorithm (Combining LZ77 and Huffman Coding).
\end{enumerate}

These techniques serve as a foundation for applications in text editors, file compression utilities, and lossless data compression standards like ZIP and PNG. In this report, we will detail the theory, implementation, and analysis of each algorithm, showcasing how they contribute to efficient storage and retrieval.

\chapter{Context-aware Autocomplete Using Tries and KMP Algorithm}
\section{Problem Statement}
Implement an autocomplete feature that suggests words based on user input and context. The system should use a Trie to store words and the KMP algorithm to match patterns in the text history for context-aware suggestions.

\section{Algorithm Explanation}
\subsection{Trie Data Structure}
A Trie is used for efficiently storing and searching strings based on prefixes. It consists of nodes where each node represents a character in the alphabet. We use the Trie to find words that match the given prefix quickly.

\subsection{KMP Pattern Matching Algorithm}
The Knuth-Morris-Pratt (KMP) algorithm is used for pattern matching within the text history. It pre-processes the pattern to create an LPS (Longest Prefix Suffix) array, allowing for efficient searching.

\section{Code Implementation}
\lstinputlisting[language=C++]{context_autocomplete.cpp}

\section{Complexity Analysis}
\begin{itemize}
    \item \textbf{Trie Insertion/Autocomplete Search:} $O(m)$, where $m$ is the length of the word.
    \item \textbf{KMP Search:} $O(n + m)$, where $n$ is the length of the text and $m$ is the length of the pattern.
\end{itemize}

\chapter{Lempel-Ziv'77 (LZ77) Compression and Decompression}
\section{Problem Statement}
Implement the Lempel-Ziv'77 (LZ77) compression and decompression algorithms for lossless data compression by identifying repeated substrings in the text.

\section{Algorithm Explanation}
\subsection{LZ77 Compression}
LZ77 encodes the text using back-referencing by identifying repeated patterns within a sliding window. The output is a sequence of tuples $(\text{offset}, \text{length}, \text{next character})$, where:
\begin{itemize}
    \item \textbf{Offset:} Distance back to the start of the matching substring.
    \item \textbf{Length:} Length of the matching substring.
    \item \textbf{Next Character:} First character following the matching substring.
\end{itemize}

\subsection{LZ77 Decompression}
LZ77 decompression reverses the process by using the $(\text{offset}, \text{length}, \text{next character})$ tuples to reconstruct the original text.

\section{Code Implementation}
\lstinputlisting[language=C++]{lz77_compression.cpp}

\section{Complexity Analysis}
\begin{itemize}
    \item \textbf{Compression:} $O(n^2)$ in the worst case due to repeated pattern search.
    \item \textbf{Decompression:} $O(n)$, where $n$ is the length of the compressed data.
\end{itemize}

\chapter{Deflate Compression Using LZ77 and Huffman Coding}
\section{Problem Statement}
Implement the Deflate compression algorithm, which combines LZ77 for dictionary compression and Huffman Coding for entropy coding to achieve efficient lossless data compression.

\section{Algorithm Explanation}
\subsection{LZ77 Phase}
The first phase uses LZ77 to identify repeated patterns in the text, storing them as tuples.

\subsection{Huffman Coding Phase}
The Huffman Coding phase builds a frequency table of the symbols generated by LZ77, constructs a Huffman Tree, and assigns binary codes to each symbol. This minimizes the space used by frequently occurring symbols.

\section{Code Implementation}
\lstinputlisting[language=C++]{deflate_compression.cpp}

\section{Complexity Analysis}
\begin{itemize}
    \item \textbf{LZ77 Compression:} $O(n^2)$ in the worst case.
    \item \textbf{Huffman Coding:} $O(n \log n)$, where $n$ is the number of distinct symbols.
\end{itemize}

\chapter{Conclusion}
The three algorithms explored in this project show how efficient data structures and algorithms can be used to solve complex text processing and compression problems. The Trie and KMP algorithm efficiently handle text suggestion problems, while LZ77 and Deflate demonstrate the principles of lossless compression. Future improvements could include optimizing the LZ77 search phase and enhancing the compression ratio through adaptive Huffman Coding.

\chapter{References}
\begin{enumerate}
    \item Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein, \textit{Introduction to Algorithms}, MIT Press, 3rd Edition.
    \item Mark Nelson, \textit{The Data Compression Book}, M\&T Books, 1991.
    \item David A. Huffman, \textit{A Method for the Construction of Minimum-Redundancy Codes}, Proceedings of the I.R.E., 1952.
\end{enumerate}

\end{document}
